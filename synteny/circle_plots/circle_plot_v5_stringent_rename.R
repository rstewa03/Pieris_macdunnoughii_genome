rm(list=ls()) #clears all variables
objects() # clear all objects
graphics.off() #close all figures
setwd("/mnt/griffin/chrwhe/Colias_eurytheme_genome/align_Zerene_cesonia")


## -----------------------------------------------------------------------
## Plot alignment between zerene cesonia and
##    Heliconious erato
## -----------------------------------------------------------------------

#notes from author luis.rodriguezcaro@umconnect.umt.edu

# Since you are interested on the circle plots I am sending you the input files and the script
# that I used to generate it in R (attached)  You should be able to recreate it using your own
# alignment files. While this script uses a specific output of a MUMmer alignment, it should
# work for any other alignment output as long as it is in tabular format. All the columns
# that you need are the coordinates of start (S) and end (E) points from your reference (R)
# and query (Q) scaffolds. In my script you will see that these columns are named  RS, RE, QS
# and QE respectively. You may also need to make sure your alignment table includes the length
# of R and Q scaffolds (named L1 and L2 in my script). As long as you name these columns the
# same way in your data the script may not require further changes.
#
# Please excuse any confusion generated by my scripting style. I wrote it during my
# Master's and I'm not an experienced programmer, so you might find that is not the
# best script to follow. Please let me know if you have any question, I'll be happy to help.

# package
# https://jokergoo.github.io/circlize_book/book/initialize-genomic-plot.html#initialize-cytoband


# Set up -----------------------------------------------------------------
# setwd('~/Documents/Projects/ZC2019/Chromosome_labeling2/')
# setwd("~/Research/software/circle_plot_genome_aignment")
options(stringsAsFactors = FALSE)
library(circlize)

# Load data --------------------------------------------------------------

palete1 <- read.table('ID_color_palette_1_Ceu_v2', header = TRUE, row.names=1)
# palete2 <- read.table('ID_color_palette_2', header = TRUE, row.names=1)

# mummer <- read.table('./ID_HED_ZC02_masked_coords.txt')
mummer <- read.table('nucmer_aln_CvZ.filt.coords',sep=',')
# colnames(mummer) <- c('RS','RE','QS','QE','L1','L2','Percent', 'per_sim',
#                       'per_stp','lenR','lenQ','frameR','frameQ', 'reference',
#                       'query')
colnames(mummer) <- c('RS','RE','QS','QE','L1','L2','Percent','lenR','lenQ',
                      'reference','query')
# hist(mummer$Percent)
# plot(mummer$Percent,mummer$L1)
# hist(log10(mummer$L1))
# quantile(mummer$Percent)
# quantile(mummer$L1)
#
# Remove short scaffolds in Zcesonia .....................................
t_per <- 88.0
t_len <- 1000

# Remove short scaffolds and reference scaf with only one hit ....................
# mummer <- mummer[mummer$lenQ >= 1200000,]
mummer <- mummer[mummer$lenQ >= 1000000,]
mummer <- mummer[mummer$L1 >= t_len,]
mummer <- mummer[mummer$Percent >= t_per,]

singles <- names(table(mummer$reference))[as.vector(table(mummer$reference)) == 1]
mummer <- mummer[!mummer$reference %in% singles,]
dim(mummer)

# Add chromosome lables ..................................................
mummer$chr <- mummer$reference

# for (i in c(1:dim(mummer)[1])){
#   name <- as.character(mummer$reference[[i]])
#   vec  <- strsplit(name,'')[[1]][7:8]
#   num  <- paste(vec, collapse = '')
#   ch   <- paste('chr_',num, sep = '')
#   mummer[i,16] <- ch
# }
for (i in c(1:dim(mummer)[1])){
  # name <- as.character(mummer$reference[[i]])
  # vec  <- strsplit(name,'')[[1]][7:8]
  # num  <- paste(vec, collapse = '')
  # ch   <- paste('chr_',num, sep = '')
  mummer[i,12] <- as.character(mummer$reference[[i]])
}

# join to
library(tidyverse)
Zerene_ID_shortname <- read.table('Zerene_ID_shortname',sep=',')
colnames(Zerene_ID_shortname) <- c('contig_name','Z_short_ID')
mummer <- mummer %>% left_join(Zerene_ID_shortname,by = c("query" = "contig_name"))

# Prepare data for ploting ................................................
# this is the order of plotting
ref <- unique(mummer$reference)
qry <- rev(unique(mummer$Z_short_ID))
# qry <- rev(unique(mummer$query))
# qry <- as.character(seq(1, length(unique(mummer$query))))

ref_len <- unique(mummer$lenR)
names(ref_len) <- ref

qry_len <- rev(unique(mummer$lenQ))
names(qry_len) <- qry

bars <- c(ref,qry)
bars <- factor(bars, levels = bars)

xlim = cbind(rep(0, length(bars)), c(ref_len, qry_len ))

r_col <- c()
# for (i in c(1:length(ref))){
#   name <- ref[i]
#   vec  <- strsplit(name,'')[[1]][7:8]
#   num  <- paste(vec, collapse = '')
#   id   <- paste('chr_', num, sep ='')
#   r_col<- c(r_col, palete1[id,'color'])
# }
# as.character(mummer$reference[[i]])
# for (i in c(1:length(ref))){
#   id <- as.character(ref[i])
#   # vec  <- strsplit(name,'')[[1]][7:8]
#   # num  <- paste(vec, collapse = '')
#   # id   <- paste('chr_', num, sep ='')
#   r_col<- c(r_col, palete1[id,'color'])
# }

# https://www.datanovia.com/en/blog/top-r-color-palettes-to-know-for-great-data-visualization/
library(RColorBrewer)
# terrain.colors
# display.brewer.pal(n = 8, name = 'Dark2')
# r_col <- terrain.colors(31)
r_col <- c(rainbow(10),rainbow(10),rainbow(10),rainbow(1))
# library(wesanderson)
# names(wes_palettes)
# wes_palette("Darjeeling2", n = 5)
# wes_palette("Zissou1", 21, type = "continuous")
# # r_col <- FantasticFox1(5)
# r_col <- c(wes_palette("Darjeeling2", n = 5),wes_palette("Darjeeling2", n = 5),wes_palette("Zissou1", 21, type = "continuous"))


# Plot alignment ...........................................................
# https://mran.microsoft.com/snapshot/2015-01-08/web/packages/circlize/vignettes/genomic_plot.pdf
# https://jokergoo.github.io/circlize_book/book/genomic-plotting-region.html#genomic-rectangles
pdf("ciros_plot_stringent_88p-1kL1-1MscafQ_rename.pdf", width = 10, height=7)
par(mar = c(1, 1, 1, 1))
circos.par(cell.padding = c(0, 0, 0, 0))

circos.initialize(factors = bars, xlim = xlim)
# circos.trackPlotRegion(factors = bars, ylim = c(0, 1), bg.border = NA,
#                        bg.col = c(r_col, rep("grey", length(qry))), track.height = 0.05,
#                        panel.fun = function(x, y) {
#                          sector.name = get.cell.meta.data("sector.index")
#                          xlim = get.cell.meta.data("xlim")
#                        })

# circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
#   chr = get.cell.meta.data("sector.index")
#   xlim = get.cell.meta.data("xlim")
#   ylim = get.cell.meta.data("ylim")
#   circos.rect(xlim[1], 0, xlim[2], 0.5, col = rand_color(1))
#   circos.text(mean(xlim), 0.9, chr, cex = 0.5, facing = "clockwise",
#               niceFacing = TRUE)
# }, bg.border = NA)

# col = sample(1:10, nrow(region), replace = TRUE)
# f = colorRamp2(breaks = c(-1, 0, 1), colors = c("green", "black", "red"))
# circos.genomicRect(region, value, col = f(value[[1]]),
#                    i = getI(...)
#                    col = i,

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
  chr = get.cell.meta.data("sector.index")
  xlim = get.cell.meta.data("xlim")
  ylim = get.cell.meta.data("ylim")
  circos.rect(xlim[1], 0, xlim[2], 0.5, col = palete1[chr,'color'])
  circos.text(mean(xlim), 1, chr, cex = 0.5, facing = "clockwise",
              niceFacing = TRUE)
}, bg.border = NA)

# works OK, but random colors for bands
# circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
#  chr = get.cell.meta.data("sector.index")
#  xlim = get.cell.meta.data("xlim")
#  ylim = get.cell.meta.data("ylim")
#  circos.rect(xlim[1], 0, xlim[2], 0.5, col = rand_color(1))
#  circos.text(mean(xlim), 1, chr, cex = 0.5, facing = "clockwise",
#              niceFacing = TRUE)
# }, bg.border = NA)



#
# circos.text(15, 5, bars, cex = 0.7, col = "black",
#             facing = , niceFacing = FALSE)

# circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
#   chr = bars
#   xlim = CELL_META$xlim
#   ylim = CELL_META$ylim
#   circos.rect(xlim[1], 0, xlim[2], 1, col = rand_color(1))
#   circos.text(mean(xlim), mean(ylim), chr, cex = 0.7, col = "white",
#               facing = "inside", niceFacing = TRUE)
#   # circos.text(5, 5, chr, cex = 0.7, col = "white",
#   #             facing = "inside", niceFacing = TRUE)
# }, track.height = 0.15, bg.border = NA)


for ( i in c(1:dim(mummer)[1])){
  circos.link(mummer$reference[i], c(mummer$RS[i],mummer$RE[i]),
              mummer$Z_short_ID[i], c(mummer$QS[i],mummer$QE[i]),
              col = palete1[mummer$chr[i],'color'])
}
dev.off()
